<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_cart_cursor</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>OBJECT</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// inherit and setup
event_inherited();

menuX = global.menuX;
menuY = global.menuY;

z = -1;
xscale = 1;
alpha  = 1;

column = getColumnFromX(x);
row    = getRowFromY(y);
getCoordsFromCell();

imageIndex = 0;
isoSprite = spr_cursor;         // actual in-game sprite
move = "";                      // used to move the cursor north, south, east or west.
pathShown = false;              // used to display/hide movement tiles.
attackPathShown = false;        // used to display possible attack tiles
rangeGrid = -1;
platformOver = 0;               // climable platform currently hovered over
objectOver = 0;                 // unit/object currently hovered over
selected = 0;                   // unit/object selected
menuPosition = 0;
targetHero = -1;
MODE = MODES.free;
keepVisible = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Controls
event_inherited();

/** FOR MODES
see setup_enums();
*/



check_controls();




// FREE ROAMING
if (MODE == MODES.free) {
    CAMERA.target = id;
    cursor_move();
    
    if (global.controls_cancel) {
        resetCursor();
    }
    
    // SELECT AN OBJECT ON MAP
    if (global.controls_ok) {
        global.controls_ok = 0;                                 // this stops the button from repeating every step
        
        var unit = ds_grid_get(grid, column, row);
        
        if !is_undefined(unit)
        and (unit &gt; -1)
        and (unit.selectable == true)
        and (global.TURN == unit)
        {
            targetHero = unit;
        }
        
        show_debug_message("targetHero = " +string(targetHero));
        
        
        
        if (targetHero &gt; -1) {                                  // check grid position for an object.
            show_debug_message("targetHero = " +string(targetHero));
            show_debug_message("targetHero.selectable = " +string(targetHero.selectable));
            
            if (targetHero.selectable == true) {
                selected = targetHero;
                MODE = MODES.objectMenu;
                
                getMenuValues(selected);
                
                if (global.options_CursorMemory) {
                    menuPosition = selected.menuPosition;     // Use the objects cursor memory?
                }
                else {
                    menuPosition = 0;                          // No? Position zero it is.
                }
            }
        }
    }
}


// CHARACTER MENU
if (MODE == MODES.objectMenu) {
    menu_cursor_controls();
    
    if (global.controls_ok) {
        global.controls_ok = 0; // prevent instant repeats
        
        switch (selected.menu[menuPosition])
        {
            case "MOVE":
                MODE = MODES.moving;
            break;
            
            case "ATTACK":
                MODE = MODES.attacking;
            break;
            
            case "SKILL":
                //MODE = MODES.skills;
            break;
            
            case "SEARCH":
                //MODE = MODES.search;
            break;
            
            case "END TURN":
                endTurn();
                MODE = MODES.finishing;
            break;
            
            case "CANCEL":
                resetCursor();
            break;
            
        }
    }
}


// MOVING UNIT
if (MODE == MODES.moving) {
    cursor_move();  // cursor can move freely around the grid, just not select outside of the range.
    
    myPath  = selected.myPath;
    
    if (pathShown == false) {
        show_movement_range();
        pathShown = true;
    }
    
    if (global.controls_ok) {
        show_debug_message("movement grid cell ("+string(column)+":"+string(row)+") contains: "+string(ds_grid_get(movementGrid,column,row)));
        
        if (ds_grid_get(movementGrid, column, row) == obj_MovementPanel) {
            panel = ds_grid_get(movementGrid, column, row);
            
            if (panel.allowMove == true) {                  // if the panel is not red (blocked)
                pathShown = false;
                selected.sourceColumn   = selected.column;  // needed for update_Grid()
                selected.sourceRow      = selected.row;     // needed for update_Grid()
                selected.targetColumn   = column;           // set the target column for the unit
                selected.targetRow      = row;              // set the target row for the unit
                selected.alarm[0]       = 1;                // tell the unit to start moving
                MODE = MODES.waiting;                       // wait while unit has finished moving
                }
            }
    }
    
    if (global.controls_cancel) {
        pathShown = false;
        teleportToCell(id, selected.sourceColumn, selected.sourceRow);
        MODE = MODES.objectMenu;
        resetCursor();
    }
}



// ATTACK
if (MODE == MODES.attacking) {
    var attackTarget = -1;
    
    myPath = selected.myPath;
    
    if (attackPathShown == false) {
        show_attack_range();
        attackPathShown = true;
    }
    
    
    // cursor movement
    if (global.controls_up)
    or (global.controls_left) {
        selected.targetIndex--;
        
        if (selected.targetIndex &lt; 0)
          then selected.targetIndex = (ds_list_size(selected.listOfTargets)-1);
          
        sout("targetIndex is " + string(selected.targetIndex));
        
        
        attackTarget = ds_list_find_value(selected.listOfTargets, selected.targetIndex);
        
        if (attackTarget &gt; -1) {
            CURSOR.column = attackTarget.column;
            CURSOR.row = attackTarget.row;
        }
        
    }
    
    
    if (global.controls_down)
    or (global.controls_right) {
        selected.targetIndex++;
        
        if (selected.targetIndex &gt; (ds_list_size(selected.listOfTargets)-1))
          then selected.targetIndex = 0;
        
    sout("targetIndex is " + string(selected.targetIndex));
          
        attackTarget = ds_list_find_value(selected.listOfTargets, selected.targetIndex);
        
        if (attackTarget &gt; -1) {
            CURSOR.column = attackTarget.column;
            CURSOR.row = attackTarget.row;
        }
    }
    
    
    if (global.controls_ok) {
        attackTarget = ds_list_find_value(selected.listOfTargets, selected.targetIndex);
        
        if (attackTarget &gt; -1) {
            attack_target(selected, attackTarget);
            selected.actedThisTurn = true;
        }
        
        // reset variables
        selected.targetIndex = 0;
    }

    
    // (note the "attack" option should be grayed out if no valid target exists)
    // allow the cursor to jump between any valid target.
    // pressing okay attacks that target.
}

// DEFEND
if (MODE == MODES.defending) {
}

// SKILLS
if (MODE == MODES.skills) {
}

// WAITING
if (MODE == MODES.waiting) {
    // do nothing.
    //draw_set_alpha(0.3);
    //mp_grid_draw(global.pathGrid);
    visible = false;
} else {
    visible = true;
}


// FINISHING
if (MODE == MODES.finishing) {
        if (global.OPTIONS_CURSOR_MEMORY == true) {
            selected.menuPosition = menuPosition;     // remember the cursor position
        }
        pathShown = false;
        resetCursor();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw GUI elements (menu, cursor, etc)
event_inherited();


if (MODE == MODES.objectMenu) {
    draw_menu();
    draw_menuCursor();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw self
event_inherited();

draw_self_ext();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
