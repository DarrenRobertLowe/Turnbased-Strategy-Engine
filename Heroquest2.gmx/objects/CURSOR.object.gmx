<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_cart_cursor</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>OBJECT</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// inherit and setup
event_inherited();

menuX = global.menuX;
menuY = global.menuY;

z = -1;
xscale = 1;
alpha = 1;

column      = getColumnFromX(x);
row         = getRowFromY(y);
getCoordsFromCell();


isoSprite = spr_cursor;         // actual in-game sprite
move = "";                      // used to move the cursor north, south, east or west.
pathShown = false;              // used to display/hide movement tiles.
rangeGrid = -1;
platformOver = 0;               // climable platform currently hovered over
objectOver = 0;                 // unit/object currently hovered over
selected = 0;                   // unit/object selected
menuPosition = 0;
targetHero = -1;
MODE = MODES.free;
keepVisible = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw GUI elements (menu, cursor, etc)
event_inherited();

if (MODE == MODES.objectMenu) {
    draw_menu();
    draw_menuCursor();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Controls
event_inherited();

// DRAW THE SPRITE
draw_self_ext();


/** MODES
 * MODE = 0   //off
 * MODE = 1   //free roaming
 * MODE = 2   //object menu
 * MODE = 3   //moving
 * MODE = 4   //attacking
 * MODE = 5   //defending
 * MODE = 6   //skills
 * MODE = 7   //waiting...
 * MODE = 8   //finishing
*/

check_controls();


// FREE ROAMING
if (MODE == MODES.free) {
    cursor_move();
    
    // SELECT AN OBJECT ON MAP
    if (global.controls_ok) {
        global.controls_ok = 0;                                 // this stops the button from repeating every step
        
        var unit = ds_grid_get(grid, column, row);
        
        if !is_undefined(unit)
        and (unit &gt; -1)
        and (unit.selectable == true)
        and (global.TURN == unit)
        {
            targetHero = unit;
        }
        
        show_debug_message("targetHero = " +string(targetHero));
        
        
        
        if (targetHero &gt; -1) {                                  // check grid position for an object.
            show_debug_message("targetHero = " +string(targetHero));
            show_debug_message("targetHero.selectable = " +string(targetHero.selectable));
            
            if (targetHero.selectable == true) {
                selected = targetHero;
                MODE = MODES.objectMenu;
                
                getMenuValues(selected);
                
                if (global.OPTIONS_CURSOR_MEMORY) {
                    menuPosition = selected.menuPosition;     // Use the objects cursor memory?
                }
                else {
                    menuPosition = 0;                          // No? Position zero it is.
                }
            }
        }
    }
}


// CHARACTER MENU
if (MODE == MODES.objectMenu) {
    menu_cursor_controls();
    
    if (global.controls_ok) {
        global.controls_ok = 0; // prevent instant repeats
        
        // MOVE
        if (selected.menu[menuPosition] == "MOVE") {  
            sourceColumn = column;
            sourceRow = row;
            MODE = MODES.moving;
        }
        
        if (selected.menu[menuPosition] == "ATTACK")then MODE = MODES.attacking;
        if (selected.menu[menuPosition] == "SKILL") then MODE = MODES.skills;
        if (selected.menu[menuPosition] == "EXIT")  then cursorMenuCancel();
    }
}


// MOVING UNIT
if (MODE == MODES.moving) {
    cursor_move();  // cursor can move freely arounnd the grid, just not select outside of the range.
    
    move = selected.move;
    myPath   = selected.myPath;
    
    if (pathShown == false) {
        show_movement_range();
        pathShown = true;
    }
    
    
    
    if (global.controls_ok) {
        if (instance_position(x, y, obj_MovementPanel)) {
            panel = instance_position(x, y, obj_MovementPanel);
            
            if (panel.allowMove == true) {                  // if the panel is not red (blocked)
                pathShown = false;
                selected.sourceColumn   = selected.column;  // needed for update_Grid()
                selected.sourceRow      = selected.row;     // needed for update_Grid()
                selected.targetColumn   = column;           // set the target column for the unit
                selected.targetRow      = row;              // set the target row for the unit
                selected.MOVING         = true;             // tell the unit that it is moving
                selected.alarm[0]       = 1;                // tell the unit to start moving
                MODE = MODES.waiting;                       // wait while unit has finished moving
                }
            }
    }
    
    if (global.controls_cancel) {
        pathShown = false;
        teleportToCell(id, sourceColumn, sourceRow);
        MODE = MODES.objectMenu;
    }
}



// ATTACK
if (MODE == MODES.attacking) {
}

// DEFEND
if (MODE == MODES.defending) {
}

// SKILLS
if (MODE == MODES.skills) {
}

// WAITING
if (MODE == MODES.waiting) {
        // do nothing.
        draw_set_alpha(0.3);
        mp_grid_draw(global.pathGrid);
}

// FINISHING
if (MODE == MODES.finishing) {

        if (global.OPTIONS_CURSOR_MEMORY == true) {
            selected.menuPosition = menuPosition;     // remember the cursor position
        }
        pathShown = false;
        selected  = 0;
        MODE = MODES.free;
        
        //ds_grid_destroy(global.MOVE_GRID);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
