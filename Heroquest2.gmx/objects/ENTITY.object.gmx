<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>OBSTACLE</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// OBJECTS THAT CAN BE PLACED ON THE GRID
event_inherited();

sprite_collision_mask(sprite_index, false, 2, 2, 2, sprite_width-2, sprite_height-2, 1, 0);

depth = DEPTH.normal;


northSprite = anim_archer_north;
southSprite = anim_archer_south;
direction   = 0;
facing      = DIRECTION.east;

MOVING      = false;
myPath      = path_add();
isoSprite   = spr_none;
selectable  = false;
xprev       = x;
yprev       = y;
//facing      = faceDirection(4); // face a random direction
keepVisible = true;

column      = getColumnFromX(x);
row         = getRowFromY(y);
isoX        = getIsometricX(column, row);
isoY        = getIsometricY(column, row);
alpha       = 1;

setup_animations();
update_sprite();
animate_alt();

if (ds_grid_get(grid, column, row) == -1)
{
    ds_grid_set(grid, column, row, id);
}
else 
{
    show_error(
        "Grid cell already occupied! #
        Error: attempted to create object "+string(object_get_name(object_index))
        +", id:" + string(id)
        +" at position : " + string(column) + ":" +string(row)
        +"# but we encountered something there already!
        #value:" +string(ds_grid_get(grid, column, row)), true);
}



/// default stats
type    = ENEMY;
name    = "Nameless";
sex     = SEXES.none;
hp      = 1;
mp      = 0;
move    = 0;
attack  = 1;
defence = 0;
weapon  = 0;
offhand = 0;
amulet  = 0;
armour  = 0;
ring1   = 0;
ring2   = 0;
hair    = 0;
face    = 0;
skin    = 0;


// DEBUG
prevDir     = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// pathfinding
MOVING = true;
global.TIMETOWALK=0;
goto_Square(targetColumn, targetRow);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// ANIMATE IF WALKING
event_inherited();

image_index += global.animationSpeed;
update_sprite();
// ANIMATE IF WALKING
if (global.isometricView)
{
    //animate();
    animate_alt();
}


// MOVEMENT
if (MOVING) {
    show_debug_message("Current frame is "+string(global.currentFrame));
    show_debug_message("MOVING = "+string(MOVING));
    global.TIMETOWALK++;
    get_direction();
    //path_speed = global.OPTIONS_MOVEMENT_SPEED;   // if using delta time you probably need to update it here
    CURSOR.MODE = MODES.waiting;                        // make cursor wait while we move
    getCellFromCoordsPrecise(x,y);                      // getCellFromCoordsPrecise(x, y);
    
    // finish moving
    if (path_position &gt;= 1) {
        getCellFromCoords(x,y);
        CURSOR.MODE = MODES.free;                       // return control to the cursor
        MOVING = false;                                 // turn off movement
        updateGrid(id, sourceColumn, sourceRow, targetColumn, targetRow);   // empty old coords and add id to new position.
        show_message("finished moving");
        show_message("Took "+string(global.TIMETOWALK));
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// update xprev and yprev
xprev = xprevious;
yprev = yprevious;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw self and animation
event_inherited();


// CARTESIAN view
if !(global.isometricView) {
    draw_set_alpha(1);
    draw_self_ext();
    draw_path_ext();
    draw_collision_mask();
    draw_set_alpha(0.25);
    mp_grid_draw(global.pathGrid);
}
else // ISOMETRIC view
{
    if  (path_position &gt; 0)
    and (path_position &lt; 1)
    {
        //draw_sprite_ext(isoSprite, image_index, getIsometricX(column, row), getIsometricY(column, row)-(tileHeight/2), image_xscale, image_yscale, 0, c_white, alpha); // -(tileHeight/2) is a bit of a hack to get the sprite to be drawn in the correct place while walking
        column  = getColumnFromXPrecise(x);
        row     = getRowFromYPrecise(y);
    }
    //else draw_self_ext();//draw_sprite(isoSprite, image_index, getIsometricX(column, row), getIsometricY(column, row));
    draw_self_ext();
    
    
    
    
    // DEBUG
    if (global.DEBUG) {
        draw_set_color(c_green);
        draw_text(
                getIsometricX(column, row),
                getIsometricY(column, row),
                "facing:"+string(getFacingAsString(facing))+
                "#direction:"+string(direction)+
                "#image index:"+string(image_index)
                );
    }
}


/*
if !place_snapped(tileWidth, tileHeight)
{
    move_snap(tileWidth, tileHeight)
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
